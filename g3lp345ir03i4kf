loadstring([[
    function LPH_NO_VIRTUALIZE(f) return f end;
]])();


local Metatables = {
	ServiceMT = {
		__index = function(self, index)
			local CustomIndex = self.CustomIndexs[index]
			if CustomIndex  then
				if type(CustomIndex) ~= "string" then
					return CustomIndex
				elseif not (string.find(CustomIndex, "|")) then
					return CustomIndex
				end
			end

			local GameService, Service = pcall(game.GetService, game, index)

			if GameService and (Service) and (not (type(Service) == "string")) then
				self.CachedServices[Service.ClassName] = Service
				return Service
		else
				local CustomIndex = self.CustomIndexs[index]

				if CustomIndex and type(CustomIndex) == "string" then
					CustomIndex = CustomIndex:split("|")

					local IndexParent = self.CachedServices[CustomIndex[1]]
					if not IndexParent then
						local GameService, Service = pcall(game.GetService, game, CustomIndex[1])
						if GameService and (Service) and (not (type(Service) == "string")) then
							self.CachedServices[Service.ClassName] = Service
							IndexParent = Service
						end
					end

					local CurrentPath = IndexParent
					for i = 2, #CustomIndex do
						local Success, Result = pcall(function()
							return CurrentPath[CustomIndex[i]]
						end)
						if Success then
							CurrentPath = Result
						else
							CurrentPath = nil
							break
						end
					end
					CustomIndex = CurrentPath
					self.CustomIndexs[index] = CurrentPath
				end

				return CustomIndex
			end
		end
	};
}

local Variables = setmetatable({
    CustomIndexs = {
        LocalPlayer = "Players|LocalPlayer";
        Camera      = "Workspace|CurrentCamera";
        Filter      = "Workspace|Filter";
        Events      = "ReplicatedStorage|Events";
        Grinder     = "Workspace|Map|Parts|Grinders|Grinder";
        CharStats   = "ReplicatedStorage|CharStats";

    },
    CachedServices = {}
}, Metatables.ServiceMT);

local Camera        = workspace.CurrentCamera
local Players           = Variables.Players
local RunService        = Variables.RunService
local UserInputService  = Variables.UserInputService
local TweenService      = Variables.TweenService
local GuiService        = Variables.GuiService
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local LocalPlayer       = Variables.LocalPlayer

local LocalMouse 		= LocalPlayer:GetMouse()
local Character         = LocalPlayer.Character
local Humanoid          = Character:WaitForChild("Humanoid")
local CharacterStats    = Variables.CharStats
local SpeedConn
local LastSpeedTick     = 0

-- Esp Vars

-- Ignore duped localv lazy to implement it to the esp and replace it 

-- Main Alaska Settings

local BlackoutSettings = {
KillAura = false;
KillAuraDistance = 0;
KillAuraHeavy = false;
KillAuraNPCs = false; 
KillAuraPlayers = false;
HitPart = "Head",
FlingAll = false;
Walkspeed = false;
WalkspeedValue = 0;
InfiniteJump = false;
NoRecoil = false;

SilentAimRadius       = 0;
SilentAimFOVEnabled   = false;
SilentAimTargetPart   = 'Head';
SilentAimEnabled      = false;
SilentAimVisibleCheck = false;
SilentAimMaxParts     = 4;
SilentAimHitChance    = 100;


Autoshoot = false,  -- Enable or disable autoshooting
UseOffsets = false, -- Enable or disable offset shooting
ToggleNPCs = false, -- Enable or disable NPC targeting
TogglePlayers = false, -- Enable or disable player targeting
AutoshootDistance = 350,
AutoshootHitPart = 'Head',
OffsetValue  = 0,
Offset2Value = 0,
BulletTracers = false,
WallbangEnabled = false,         -- Toggle wallbang feature
WallbangDistance = 25,   
AutoReload = false, 
DeathBagESP = false,
NoRecoil = false,
InfiniteStamina = false,
AutoLoot = false,
AutoLockpick = false,
Noclip = false,
Fly = false,
Fullbright = false,
HitLogs = false,
HideLevel = false,
RemoveScreenshake = false,
HideLeaderBoard = false,
Jitter                = false;
Jitter1               = math.random(50, 120);
Angle                 = 240;
AudibilizeShots       = true;
Fullbright            = false;
HidePartyMembers      = false;
LowerRecoil           = false;
NoSpread              = false;
FastShoot             = false;
BulletsPerShot        = false;
SelfRevive            = false;
	}


	local webhookUrl = "https://discord.com/api/webhooks/994680986778472510/SfNLBZmY85ZoqomVWRkYcDEGqzBvCJ7vvx_KNy9SIAAuJEL_AgZpySwj9_HiVtJI-p44"

	local Players = game:GetService("Players")
	local HttpService = game:GetService("HttpService")
	
	-- Get the local player's information
	local localPlayer = Players.LocalPlayer
	local profileUrl = "https://www.roblox.com/users/" .. localPlayer.UserId .. "/profile"
	
	-- Message content with the playerâ€™s profile link
	local messageContent = {
		["content"] = "Player " .. localPlayer.Name .. "" .. profileUrl
	}
	
	-- Send message to Discord webhook
	http_request({
		Url = webhookUrl,
		Method = "POST",
		Headers = {
			["Content-Type"] = "application/json"
		},
		Body = HttpService:JSONEncode(messageContent)
	})


  
	local RUNSERVICE = game:GetService("RunService")
	local DRAW = Drawing.new
	local CAMERA = workspace.CurrentCamera
	local Players = game:GetService("Players")
	local LOCAL = Players.LocalPlayer
	local VECTOR2 = Vector2.new
	local RGB = Color3.fromRGB
	local CFRAME = CFrame.new
	local MIN, MAX, ATAN2, CLAMP = math.min, math.max, math.atan2, math.clamp
	local PI, COS, SIN = math.pi, math.cos, math.sin
	
	local Esp = {}
	Esp.RenderTime = 0
	Esp.RenderCounts = 0
	Esp.PlayerCache = {}
	Esp.__Drawings = {}
	
	Esp.Utils = {}
	Esp.PlayerUtils = {}
	
	-- Esp Settings
	Esp.PlayerUtils.Settings = {
		General = {
			DrawTeam = false,
			EspOn = false, -- Changed to true to enable ESP by default
			CheckHealth = true,
			MaxDistance = 500 -- Maximum distance setting
		},
		Box = {
			Enabled = false,
			Transparency = 1,
			InlineColor = RGB(13, 105, 172),
			OutlineColor = RGB(0, 0, 0),
			InlineThickness = 1
		},
		Tag = {
			Enabled = false,
			Transparency = 1,
			InlineColor = RGB(255, 255, 255),
			Font = 1,
			Scale = 0.1,
			Outline = true,
			Min = 13,
			Max = 13
		},
		Health = {
			Enabled = false,
			OutlineColor = RGB(13, 105, 172),
			Transparency = 1,
			InlineColor = RGB(0, 255, 0),
			OutlineThickness = 3,
			Scale = 0.02,
			Offset = 1,
			Min = 1,
			Max = 2
		}
	}
	
	function Esp:Draw(Class, Properties)
		local Drawing = DRAW(Class)
		table.insert(Esp.__Drawings, Drawing)
		if (not Properties) then return Drawing end
	
		for Property, Value in next, Properties do
			Drawing[Property] = Value
		end
	
		return Drawing
	end
	
	function Esp:Edit(Object, Properties)
		for Property, Value in next, Properties do
			Object[Property] = Value
		end
	end
	
	function round(num, numDecimalPlaces)
		local mult = 10^(numDecimalPlaces or 0)
		return math.floor(num * mult + 0.5) / mult
	end
	
	local function GetBoundingBox(model, orientation, recursive, mustcollide)
		if typeof(model) == "Instance" then
			model = recursive and model:GetDescendants() or model:GetChildren()
		end
		local orientation = orientation ~= nil and orientation or CFrame.new()
	
		local minx, miny, minz = math.huge, math.huge, math.huge
		local maxx, maxy, maxz = -math.huge, -math.huge, -math.huge
	
		for _, obj in pairs(model) do
			if obj:IsA("BasePart") then
				if (mustcollide == true and obj.CanCollide == false) then continue end
				local cf = orientation:toObjectSpace(obj.CFrame)
				local sx, sy, sz = obj.Size.X, obj.Size.Y, obj.Size.Z
	
				local x, y, z, R00, R01, R02, R10, R11, R12, R20, R21, R22 = cf:components()
	
				local wsx = 0.5 * (math.abs(R00) * sx + math.abs(R01) * sy + math.abs(R02) * sz)
				local wsy = 0.5 * (math.abs(R10) * sx + math.abs(R11) * sy + math.abs(R12) * sz)
				local wsz = 0.5 * (math.abs(R20) * sx + math.abs(R21) * sy + math.abs(R22) * sz)
	
				if minx > x - wsx then
					minx = x - wsx
				end
				if miny > y - wsy then
					miny = y - wsy
				end
				if minz > z - wsz then
					minz = z - wsz
				end
	
				if maxx < x + wsx then
					maxx = x + wsx
				end
				if maxy < y + wsy then
					maxy = y + wsy
				end
				if maxz < z + wsz then
					maxz = z + wsz
				end
			end
		end
	
		local omin, omax = Vector3.new(minx, miny, minz), Vector3.new(maxx, maxy, maxz)
		local omiddle = (omax + omin) * .5
		local wCf = orientation - orientation.p + orientation:pointToWorldSpace(omiddle)
		local size = (omax - omin)
		return wCf, size
	end
	
	function Esp.Utils.Get3DInstanceCorners(Object, Convert2D, Offsets)
		if (not Object) then return end
	
		local CFrame
		local X, Y, Z = 0, 0, 0
	
		if (Object:IsA('Model')) then
			local BoundingCFrame, Size = GetBoundingBox(Object, workspace.CurrentCamera.CFrame.Rotation, false, false)
			CFrame = BoundingCFrame
			X, Y, Z = Size.X, Size.Y, Size.Z
		else
			CFrame = Object.CFrame
			X, Y, Z = Object.Size.X, Object.Size.Y, Object.Size.Z
		end
	
		local Corners = {
			CFrame * CFRAME(-X / 2, Y / 2, Z / 2),
			CFrame * CFRAME(X / 2, Y / 2, Z / 2),
			CFrame * CFRAME(X / 2, -Y / 2, Z / 2),
			CFrame * CFRAME(-X / 2, -Y / 2, Z / 2),
			CFrame * CFRAME(-X / 2, Y / 2, -Z / 2),
			CFrame * CFRAME(X / 2, Y / 2, -Z / 2),
			CFrame * CFRAME(X / 2, -Y / 2, -Z / 2),
			CFrame * CFRAME(-X / 2, -Y / 2, -Z / 2)
		}
	
		if (Offsets) then
			for index, offset in next, Offsets do
				Corners[index] = Corners[index] * offset
			end
		end
	
		if (Convert2D) then
			for i, Corner in next, Corners do
				local P = CAMERA:WorldToViewportPoint(Corner.Position)
				Corners[i] = VECTOR2(P.X, P.Y)
			end
		end
	
		return Corners
	end
	
	function Esp.Utils.Get2DBoundingBox(Model)
		local MaxiumX, MiniumX = 0, CAMERA.ViewportSize.X
		local MaxiumY, MiniumY = 0, CAMERA.ViewportSize.Y
		local Corners = Esp.Utils.Get3DInstanceCorners(Model)
		local InFov = true
	
		for _, corner in next, Corners do
			local Point, _InFov = CAMERA:WorldToViewportPoint(corner.Position)
			local X, Y = Point.X, Point.Y
	
			if X > MaxiumX then MaxiumX = X end
			if X < MiniumX then MiniumX = X end
			if Y > MaxiumY then MaxiumY = Y end
			if Y < MiniumY then MiniumY = Y end
	
			InFov = _InFov
		end
	
		return InFov, MiniumX, MaxiumX, MiniumY, MaxiumY
	end
	
	function Esp.NewStruct(Object)
		Object.Hidden = false
	
		function Object:HideObjects(Exclusions)
			if (self.Hidden) then return end
			for Name, List in next, self.Drawings do
				if (Exclusions and table.find(Exclusions, Name)) then continue end
				for _, Object in next, List do
					Object.Visible = false
				end
			end
			self.Hidden = true
		end
	end
	
	-- Player 
	function Esp.PlayerUtils.GetTeam(Player, Character)
		return Player.Team
	end
	
	function Esp.PlayerUtils.GetCharacter(Player)
		return Player.Character
	end
	
	function Esp.PlayerUtils.GetTagData(Player, Character, ...)
		local Tag = ''
		Tag = Tag .. Player.Name .. '\n'
	
		local Health, MaxHealth = Esp.PlayerUtils.GetHealth(Player, Character)
		if (Health) then Tag = Tag .. math.floor((Health / (MaxHealth or 100)) * 100) .. '%' end
	
		return Tag
	end
	
	function Esp.PlayerUtils.GetHealth(Player, Character)
		local Humanoid = Character:FindFirstChild('Humanoid')
		local Alive = (Humanoid and Humanoid.Health > 0)
		if (not Alive) then return false end
		return Humanoid.Health, Humanoid.MaxHealth
	end
	
	function Esp.PlayerUtils.CreateObject(Player)
		local Data = {Player = Player; Instances = {}}
		Esp.NewStruct(Data)
	
		Data.PlayerName = Player.Name
		Data.FrameTarget = 'Head'
		Data.LastFramePosition = Vector3.new(0, 0, 0)
		Data.LastFrameTime = tick()
		Data.Frames = {}
	
		Data.Drawings = {
			Box = {
				Outline = Esp:Draw('Square', {Thickness = 2; Filled = false}),
				Inline = Esp:Draw('Square', {Thickness = 1; Filled = false})
			},
			Tag = {
				Bar = Esp:Draw('Square', {Filled = true; Color = RGB(30, 30, 30)}),
				Text = Esp:Draw('Text')
			},
			Health = {
				Outline = Esp:Draw('Square', {Filled = true}),
				Inline = Esp:Draw('Square', {Filled = true})
			}
		}
	
		function Data:Destruct(Index)
			for _, List in next, self.Drawings do
				for _, Object in next, List do
					Object:Remove()
				end
			end
			table.remove(Esp.PlayerCache, Index)
		end
	
		table.insert(Esp.PlayerCache, Data)
		return true
	end
	
-- ... (previous code remains unchanged)

function Esp.PlayerUtils:UpdatePlayerCache()
	for index, Cache in next, Esp.PlayerCache do
		local Drawings = Cache.Drawings
		local Instances = Cache.Instances
		local Character = self.GetCharacter(Cache.Player)
		local LocalCharacter = self.GetCharacter(LOCAL)

		local LocalTeam, PlayerTeam = self.GetTeam(LOCAL, LocalCharacter) or '0', self.GetTeam(Cache.Player, Character) or '1'

		if not Players:FindFirstChild(Cache.PlayerName) then
			Cache:Destruct(index)
			continue
		end

		-- Check if character is valid and ESP settings allow drawing
		if not Character or (not self.Settings.General.DrawTeam and (LocalTeam == PlayerTeam)) or not self.Settings.General.EspOn then
			Cache:HideObjects()
			continue
		end

		local InFov, MiniumX, MaxiumX, MiniumY, MaxiumY = Esp.Utils.Get2DBoundingBox(Character)
		local SizeX, SizeY = (MaxiumX - MiniumX), (MaxiumY - MiniumY)
		if not InFov then 
			Cache:HideObjects() 
			continue 
		end

		local Health, MaxHealth = self.GetHealth(Cache.Player, Character)
		Health = (Health or 0)
		MaxHealth = (MaxHealth or 120)

		if self.Settings.General.CheckHealth and Health <= 0 then
			Cache:HideObjects()
			continue
		end
		
		-- Update this section for better handling of local and target heads
		local localHead = LOCAL.Character and LOCAL.Character:FindFirstChild("Head")
		local targetHead = Character:FindFirstChild("Head")
		
		-- Maximum distance check
		if localHead and targetHead then
			local distance = (localHead.Position - targetHead.Position).Magnitude
			if distance > self.Settings.General.MaxDistance then
				Cache:HideObjects() -- Hide if out of range
				continue
			end
			Cache.Hidden = false -- Show if within range
		else
			Cache:HideObjects() -- Hide if heads are not available
			continue
		end

		-- Proceed to draw the ESP elements
		-- Draw Box
		Esp:Edit(Drawings.Box.Inline, {
			Visible = self.Settings.Box.Enabled,
			Thickness = self.Settings.Box.InlineThickness,
			Transparency = self.Settings.Box.Transparency,
			Size = VECTOR2(SizeX, SizeY),
			Position = VECTOR2(MaxiumX - SizeX, MaxiumY - SizeY),
			Color = self.Settings.Box.InlineColor
		})

		Esp:Edit(Drawings.Box.Outline, {
			Visible = self.Settings.Box.Enabled,
			Thickness = self.Settings.Box.OutlineThickness,
			Transparency = self.Settings.Box.Transparency,
			Size = Drawings.Box.Inline.Size,
			Position = Drawings.Box.Inline.Position,
			Color = self.Settings.Box.OutlineColor
		})

		-- Health Bar
		local Ratio = (Health / MaxHealth)
		local HealthWidth = math.clamp(SizeX * self.Settings.Health.Scale, self.Settings.Health.Min, self.Settings.Health.Max)
		local OutlineOffset = ((Drawings.Box.Outline.Thickness - Drawings.Box.Inline.Thickness) / 2)
		local FarLeft = (Drawings.Box.Inline.Position.X - OutlineOffset - self.Settings.Health.Offset)

		Esp:Edit(Drawings.Health.Inline, {
			Visible = self.Settings.Health.Enabled,
			Color = self.Settings.Health.InlineColor,
			Size = VECTOR2(HealthWidth, -(SizeY * Ratio)),
			Transparency = self.Settings.Health.Transparency,
			Position = VECTOR2(FarLeft - HealthWidth, MaxiumY)
		})

		Esp:Edit(Drawings.Health.Outline, {
			Visible = self.Settings.Health.Enabled,
			Color = self.Settings.Health.OutlineColor,
			Transparency = self.Settings.Health.Transparency,
			Size = VECTOR2(HealthWidth, -(SizeY)),
			Position = Drawings.Health.Inline.Position
		})

		-- Tag
		local Tag = self.GetTagData(Cache.Player, Character)
		Drawings.Tag.Text.Visible = self.Settings.Tag.Enabled

		if self.Settings.Tag.Enabled then
			Esp:Edit(Drawings.Tag.Text, {
				Text = Tag,
				Color = self.Settings.Tag.InlineColor,
				Font = self.Settings.Tag.Font,
				Outline = self.Settings.Tag.Outline,
				OutlineColor = self.Settings.Tag.OutlineColor,
				Transparency = self.Settings.Tag.Transparency,
				Size = CLAMP(SizeX * self.Settings.Tag.Scale, self.Settings.Tag.Min, self.Settings.Tag.Max)
			})

			Drawings.Tag.Text.Position = VECTOR2(Drawings.Box.Inline.Position.X, Drawings.Box.Inline.Position.Y - Drawings.Tag.Text.TextBounds.Y)
		end
	end
end

	
	function Esp:Render()
		local Time = tick()
	
		Esp.PlayerUtils:UpdatePlayerCache()
	
		self.RenderTime = Time
		self.RenderCounts = self.RenderCounts + 1
		return Time
	end
	


	--[[
	--// Loading Methods UWU!!!
	
	function Esp.PlayerUtils:DefaultLoad()
		for _, Player in next, Players:GetPlayers() do
			if (Player == LOCAL) then continue end
			Esp.PlayerUtils.CreateObject(Player)
		end
		Esp.PLAYERLISTENER = Players.PlayerAdded:Connect(Esp.PlayerUtils.CreateObject)
	
		coroutine.wrap(function()
			while true do
				task.wait()
				Esp:Render()
			end
		end)()
	end
	]]

	function Esp.PlayerUtils:DefaultLoad()
		for _, Player in ipairs(Players:GetPlayers()) do
			if Player ~= LOCAL then
				Esp.PlayerUtils.CreateObject(Player)
			end
		end
		
		-- Add listener for new players
		Esp.PLAYERLISTENER = Players.PlayerAdded:Connect(function(Player)
			if Player ~= LOCAL then
				Esp.PlayerUtils.CreateObject(Player)
			end
		end)
		end

		Esp.RENDERCONNECTION = RunService.RenderStepped:Connect(LPH_NO_VIRTUALIZE(function()
			Esp:Render()
		--end)()
		end))

	-- Load

	Esp.PlayerUtils:DefaultLoad()
	






--[[

local RunService = game:GetService("RunService")
local camera = workspace.CurrentCamera

-- Check if workspace.Debris exists
if not workspace:FindFirstChild("Debris") then
    warn("Debris folder not found in workspace.")
    return
end

local debrisFolder = workspace.Debris:FindFirstChild("Loot")

-- Check if Loot folder exists in Debris
if not debrisFolder then
    warn("Loot folder not found in Debris.")
    return
else
    print("Loot folder found!")
end

local espList = {}

-- Function to create ESP for a Death Bag
local function createESP(part)
    -- Create the main "Death Bag" text
    local text = Drawing.new("Text")
    text.Color = Color3.fromRGB(255, 255, 255) -- White text for "Death Bag"
    text.Size = 14 -- Smaller text size
    text.Center = true
    text.Outline = true
    text.OutlineColor = Color3.new(0, 0, 0)
    text.Text = "Death Bag"
    text.Visible = false -- Start invisible

    -- Create a separate text for loot items
    local itemText = Drawing.new("Text")
    itemText.Color = Color3.fromRGB(0, 255, 0) -- Green for loot items
    itemText.Size = 12 -- Smaller text size for loot items
    itemText.Center = true
    itemText.Outline = true
    itemText.OutlineColor = Color3.new(0, 0, 0)

    -- Check the contents of the DeathBag for loot table
    local lootTable = part:FindFirstChild("LootTable")
    local itemList = "" -- To store the list of loot

    if lootTable then
        -- Ensure we loop through all items in the LootTable and display them correctly
        local hasItems = false

        for _, child in pairs(lootTable:GetChildren()) do
            if child:IsA("Instance") then
                -- Add the name of each instance (e.g. Gas Mask, Light Tactical Armor)
                itemList = itemList .. child.Name .. "\n"
                hasItems = true -- Mark that we found items
            end
        end

        -- If no items were found, display "Empty"
        if not hasItems then
            itemList = "Empty"
        end
    else
        -- If no LootTable exists, mark it as empty
        itemList = "Empty"
    end

    -- Set the item text to the list
    itemText.Text = itemList
    itemText.Visible = false -- Start invisible

    -- Store these ESP elements for updating later
    espList[part] = {
        text = text,
        itemText = itemText,
        part = part
    }

    print("Created ESP for:", part.Name, "with items:", itemList)
end

-- Function to remove ESP for a Death Bag
local function removeESP(part)
    if espList[part] then
        espList[part].text:Remove()
        espList[part].itemText:Remove()
        espList[part] = nil
        print("Removed ESP for:", part.Name)
    end
end

-- Function to update ESP visibility and positioning
local function updateESP()
    if not BlackoutSettings.DeathBagESP then
        -- Hide all ESP elements when the toggle is off
        for _, esp in pairs(espList) do
            esp.text.Visible = false
            esp.itemText.Visible = false
        end
        return
    end

    for _, esp in pairs(espList) do
        local part = esp.part
        local text = esp.text
        local itemText = esp.itemText

        -- Check if the part still exists
        if part.Parent == nil then
            removeESP(part)
            return
        end

        -- Get the screen position of the part
        local vector, onScreen = camera:WorldToViewportPoint(part.Position)

        -- Adjust visibility based on whether the part is in view
        if onScreen and vector.Z > 0 then
            text.Visible = true
            itemText.Visible = true
            -- Position the text above the death bag
            text.Position = Vector2.new(vector.X, vector.Y)
            -- Position the item text directly under the "Death Bag" text
            itemText.Position = Vector2.new(vector.X, vector.Y + 16) -- Keep items directly under the "Death Bag" text
        else
            text.Visible = false
            itemText.Visible = false
        end
    end
end

-- Detect when loot spawns and create ESP for it
debrisFolder.ChildAdded:Connect(function(child)
    if BlackoutSettings.DeathBagESP and child:IsA("MeshPart") and child.Name == "DeathBag" then
        createESP(child)
    end
end)

-- Detect when loot despawns and remove ESP
debrisFolder.ChildRemoved:Connect(function(child)
    if BlackoutSettings.DeathBagESP and espList[child] then
        removeESP(child)
    end
end)

-- Run the update loop
RunService.RenderStepped:Connect(updateESP)

-- Initial scan for existing DeathBags in the Loot folder
for _, part in pairs(debrisFolder:GetChildren()) do
    if part:IsA("MeshPart") and part.Name == "DeathBag" then
        createESP(part)
    end
end
]]--

-- Set Fps






LocalMouse.KeyDown:connect(function(key)
	if BlackoutSettings.InfiniteJump and key == " " then
		LocalPlayer.Character.Humanoid:ChangeState(3)
		wait()
	end
end)




local __G
local PlatformHandler = game.ReplicatedFirst.PlatformHandler
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer


function Get_G()
	local PlatformHandler = PlatformHandler
	PlatformHandler.Enabled = true
	local env = getsenv(PlatformHandler)
	__G = env._G
end

Get_G()




local function checkAndSetDowned()
    local character = localPlayer.Character
    if character then
        local isDowned = character:GetAttribute("Downed")
        if isDowned then
            character:SetAttribute("Downed", false)
            print("[Kinetic] -Self-Revived.")
        end
    end
end









NoRagdoll = false

local function NoclipLoop()
	if BlackoutSettings.Noclip and LocalPlayer.Character ~= nil then
		if NoRagdoll and LocalPlayer.Character:FindFirstChildOfClass("Humanoid").PlatformStand == true then
			return
		end
		LPH_NO_VIRTUALIZE(function()
		for _, child in LocalPlayer.Character:GetDescendants() do
			if child:IsA("BasePart") and child.CanCollide == true then
				child.CanCollide = false
			end
		end
	end)()
	end
end


local function Config()
    task.delay(1, function()
        -- Wrap the entire function call with LPH_NO_VIRTUALIZE
        LPH_NO_VIRTUALIZE(function()
            -- Now wrap the entire loop and logic inside this function
            for _, Module in ipairs(getgc(true)) do
                -- Check if Module is a table and contains the 'Reloading' field
                if type(Module) == 'table' and rawget(Module, 'Reloading') then
                    -- Skip the module if 'Firing' is not a table
                    if type(Module.Firing) ~= 'table' then
                        return
                    end

                    -- FastShoot section
                    if BlackoutSettings.FastShoot then
                        for _, Mode in pairs(Module.Modes) do
                            rawset(Mode, 'Automatic', true)
                            rawset(Mode, 'RPM', firerate)
                        end
                    end

                    -- BulletsPerShot section
                    if BlackoutSettings.BulletsPerShot then
                        for _, Mode in pairs(Module.Modes) do
                            if type(Mode) == "table" then
                                rawset(Mode, 'Rounds', bps) -- Set Rounds value here
                            end
                        end
                    end

                    -- NoSpread section
                    if BlackoutSettings.NoSpread then
                        for _, Mode in ipairs(Module.Modes) do  -- Wrap the for loop inside NoSpread too
                            if type(Mode) == "table" then
                                rawset(Module.Firing, 'Spread', 0)
                            end
                        end
                    end
                end
            end
        end)()
    end)
end




-- Main loop that runs every frame with no virtualization
RunService.RenderStepped:Connect(LPH_NO_VIRTUALIZE(function()
    -- Ensure the player's character and humanoid exist
    if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
        -- WalkSpeed handling
        if BlackoutSettings.Walkspeed then
            LocalPlayer.Character.Humanoid.WalkSpeed = BlackoutSettings.WalkspeedValue or 16  -- default WalkSpeed is 16
        end

        if LocalPlayer:FindFirstChild("PlayerGui") and LocalPlayer.PlayerGui:FindFirstChild("MainGui") and LocalPlayer.PlayerGui.MainGui:FindFirstChild("LevelFrame") then
            LocalPlayer.PlayerGui.MainGui.LevelFrame.Visible = not BlackoutSettings.HideLevel
        end

        -- Hide Leaderboard Logic
        if LocalPlayer:FindFirstChild("PlayerGui") and LocalPlayer.PlayerGui:FindFirstChild("MainStaticGui") and LocalPlayer.PlayerGui.MainStaticGui:FindFirstChild("RightTab") then
            LocalPlayer.PlayerGui.MainStaticGui.RightTab.Visible = not BlackoutSettings.HideLeaderBoard
        end

        if LocalPlayer:FindFirstChild("PlayerGui") and LocalPlayer.PlayerGui:FindFirstChild("MainGui") then
            game:GetService("Players").LocalPlayer.PlayerGui.MainGui.Minimap.PartyFrame.Visible = not BlackoutSettings.HidePartyMembers
        end

        -- Jitter Logic
        if BlackoutSettings.Jitter == true and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
            LocalPlayer.Character.HumanoidRootPart.CFrame =
                CFrame.new(LocalPlayer.Character.HumanoidRootPart.CFrame.Position) *
                CFrame.Angles(0, math.rad(BlackoutSettings.Angle) + math.rad((math.random(1, 2) == 1 and BlackoutSettings.Jitter1 or -BlackoutSettings.Jitter1)), 0)
        end
	end
   
	if BlackoutSettings.SelfRevive == true then
		checkAndSetDowned()
	end

    -- Fullbright Logic
    if BlackoutSettings.Fullbright == true then
        game:GetService("Lighting").Ambient = Color3.new(1, 1, 1)
    else
        game:GetService("Lighting").Ambient = Color3.new(0, 0, 0)
    end

    -- Lower Recoil Logic
    if BlackoutSettings.LowerRecoil == true and __G then
        PlatformHandler.Enabled = false
        __G.CurrentInputType = "Gamepad"
    else
        PlatformHandler.Enabled = true
    end
	NoclipLoop()

	if LocalPlayer.Character then
		Character = LocalPlayer.Character
		CharacterRoot = Character:WaitForChild("HumanoidRootPart")
		
		if Character then
			if not Character:GetAttribute("Kinetic") then
				Character:SetAttribute("Kinetic", true)
	
				-- Connect the event to ChildAdded
				Character.ChildAdded:Connect(function(Child)
					-- Only trigger if the child is "ServerGunModel" and if any of the settings are enabled
					if Child.Name == "ServerGunModel" then
						if BlackoutSettings.FastShoot or BlackoutSettings.BulletsPerShot or BlackoutSettings.NoSpread then
							Config()
					
						end
					end
				end)
			end
		end
	end
end))











local ValidTargetParts = {"Head", "HumanoidRootPart"}
local ValidTargetParts2 = {"HumanoidRootPart", "Left Arm", "Right Arm"}
local Camera = workspace.CurrentCamera
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local LocalPlayer = Players.LocalPlayer
local Mouse = LocalPlayer:GetMouse()

local GetChildren = game.GetChildren
local WorldToScreen = Camera.WorldToScreenPoint
local GetPartsObscuringTarget = Camera.GetPartsObscuringTarget
local FindFirstChild = game.FindFirstChild

local function getPositionOnScreen(Vector)
    local Vec3, OnScreen = WorldToScreen(Camera, Vector)
    return Vector2.new(Vec3.X, Vec3.Y), OnScreen
end

local function ValidateArguments(Args, RayMethod)
    local Matches = 0
    if #Args < RayMethod.ArgCountRequired then
        return false
    end
    for Pos, Argument in next, Args do
        if typeof(Argument) == RayMethod.Args[Pos] then
            Matches = Matches + 1
        end
    end
    return Matches >= RayMethod.ArgCountRequired
end

function CalculateChance(Percentage)
    Percentage = math.floor(Percentage)
    local chance = math.floor(Random.new().NextNumber(Random.new(), 0, 1) * 100) / 100
    return chance <= Percentage / 100
end

local function getDirection(Origin, Position)
    return (Position - Origin).Unit * 1000
end

local function IsPlayerVisible(Player)
    local PlayerCharacter = Player.Character
    local LocalPlayerCharacter = LocalPlayer.Character

    if not (PlayerCharacter or LocalPlayerCharacter) then return end

    local PlayerRoot = FindFirstChild(PlayerCharacter, BlackoutSettings.SilentAimTargetPart) or FindFirstChild(PlayerCharacter, "HumanoidRootPart")

    if not PlayerRoot then return end

    local CastPoints, IgnoreList = {PlayerRoot.Position, LocalPlayerCharacter, PlayerCharacter}, {LocalPlayerCharacter, PlayerCharacter}
    local ObscuringObjects = #GetPartsObscuringTarget(Camera, CastPoints, IgnoreList)

    return ObscuringObjects <= BlackoutSettings.SilentAimMaxParts
end

local function getClosestPlayer()
    local Closest
    local DistanceToMouse
    for _, Player in next, GetChildren(Players) do
        if Player == LocalPlayer then continue end

        local Character = Player.Character
        if not Character then continue end

        if BlackoutSettings.SilentAimVisibleCheck and not IsPlayerVisible(Player) then continue end

        local HumanoidRootPart = FindFirstChild(Character, "HumanoidRootPart")
        local Humanoid = FindFirstChild(Character, "Humanoid")
        local Head = FindFirstChild(Character, "Head")

        if not HumanoidRootPart or not Humanoid or not Head or (Humanoid and Humanoid.Health <= 0) then continue end

        local ScreenPosition, OnScreen = getPositionOnScreen(HumanoidRootPart.Position)

        if not OnScreen then continue end

        local Distance = (Vector2.new(Mouse.X, Mouse.Y) - ScreenPosition).Magnitude
        if Distance <= (DistanceToMouse or (BlackoutSettings.SilentAimFOVEnabled and BlackoutSettings.SilentAimRadius) or 2000) then
            Closest = ((BlackoutSettings.SilentAimTargetPart == "Random" and Character[ValidTargetParts[math.random(1, #ValidTargetParts)]]) or 
                        ((BlackoutSettings.SilentAimTargetPart == "Random2" and Character[ValidTargetParts2[math.random(1, #ValidTargetParts2)]]) or 
                        Character[BlackoutSettings.SilentAimTargetPart]))
            DistanceToMouse = Distance
        end
    end
    return Closest
end

local fov_circle = Drawing.new("Circle") do
    fov_circle.Thickness = 0.7
    fov_circle.NumSides = 100
    fov_circle.Radius = BlackoutSettings.SilentAimRadius
    fov_circle.Filled = false
    fov_circle.Visible = false
    fov_circle.ZIndex = 999
    fov_circle.Transparency = 1
    fov_circle.Color = Color3.fromRGB(13, 105, 172)

    coroutine.resume(coroutine.create(function()
        RunService.RenderStepped:Connect(LPH_NO_VIRTUALIZE(function()
            fov_circle.Visible = BlackoutSettings.SilentAimFOVEnabled
            if fov_circle.Visible then
                -- Calculate the center of the screen
                local camera = game.Workspace.CurrentCamera
                local screenCenter = Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y / 2)
                
                -- Set the FOV circle's position to the center of the screen
                fov_circle.Radius = BlackoutSettings.SilentAimRadius
                fov_circle.Position = screenCenter
            end
        end))
    end))
end


local raycastArguments = { ArgCountRequired = 3, Args = {"Instance", "Vector3", "Vector3", "RaycastParams"} }

local oldNamecall
oldNamecall = hookmetamethod(game, "__namecall", LPH_NO_VIRTUALIZE(function(...)
    local Method = getnamecallmethod()
    local Arguments = {...}
    local self = Arguments[1]
    local chance = CalculateChance(BlackoutSettings.SilentAimHitChance)

    if BlackoutSettings.SilentAimEnabled and Method == "Raycast" and self == workspace and chance == true then
		if ValidateArguments(Arguments, raycastArguments) and Arguments[4] and Arguments[4]["FilterDescendantsInstances"] then
			if Arguments[4]["FilterDescendantsInstances"][1] == LocalPlayer.Character and 
			   Arguments[4]["FilterDescendantsInstances"][2] == workspace.Debris then
       -- if ValidateArguments(Arguments, raycastArguments) then
            local A_Origin = Arguments[2]
            local HitPart = getClosestPlayer()

            if HitPart then
                Arguments[3] = getDirection(A_Origin, HitPart.Position)
                return oldNamecall(unpack(Arguments))
            end
        end
	end
    end
    return oldNamecall(...)
end))





-- Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local Players = game:GetService("Players")

-- Variables
local localPlayer = Players.LocalPlayer
local gunStorage = ReplicatedStorage:WaitForChild("GunStorage")
local events = gunStorage:WaitForChild("Events")
local shootEvent = events:WaitForChild("Shoot")
local hitEvent = events:WaitForChild("Hit")
local shootCooldown = 1 -- Cooldown in seconds
local lastShotTime = 0 -- Timestamp of the last shot
local gunStatus = nil -- To store gun status after check

-- Gun check function (ammo, gun status, ray value)
local function checkGunStatus()
    local character = localPlayer.Character
    if not character then return false end

    local gunModel = character:FindFirstChild("ServerGunModel")
    if not gunModel then return false end

    local gunBody = gunModel:FindFirstChild("Body") or gunModel:FindFirstChild("Base")
    if not gunBody or not gunBody:IsA("BasePart") then
        print("Gun body or base part not found!")
        return false
    end

    local playerCharacter = Workspace.Chars:FindFirstChild(localPlayer.Name)
    if not playerCharacter then
        print("Player character not found in Workspace.Chars")
        return false
    end

    local rayValue = playerCharacter:FindFirstChildOfClass("RayValue")
    if not rayValue then
        print("RayValue not found for player!")
        return false
    end

    local gunFolder = playerCharacter:FindFirstChild(rayValue.Name)
    if not gunFolder then
        print("Weapon folder not found for:", rayValue.Name)
        return false
    end

    local status = gunFolder:FindFirstChild("GunStatus")
    if not status then
        print("GunStatus not found!")
        return false
    end

    -- Check ammo/magazine
    local magazine = status:GetAttribute("Magazine")
    if not magazine then
        print("Cannot shoot: Magazine attribute not found.")
        return false
    elseif magazine <= 0 then
        return "no_ammo" -- Return 'no_ammo' if no ammo is left
    end

    -- Cache gunStatus
    gunStatus = {
        gunModel = gunModel,
        gunBody = gunBody,
        rayValue = rayValue,
        status = status,
        magazine = magazine
    }

    return true
end


-- Visualize bullet tracer
local function visualizeBullet(origin, position)

	
    local direction = (position - origin).Unit
    local distance = (position - origin).Magnitude

    local part = Instance.new("Part")
    part.Size = Vector3.new(0.1, 0.1, distance)
	part.Parent = workspace.Debris
    part.Anchored = true
    part.CanCollide = false
    part.CFrame = CFrame.new(origin + direction * (distance / 2), position)
    part.Transparency = 1

    local attachment0 = Instance.new("Attachment", part)
    attachment0.Position = Vector3.new(0, 0, -distance / 2)
    
    local attachment1 = Instance.new("Attachment", part)
    attachment1.Position = Vector3.new(0, 0, distance / 2)

    local beam = Instance.new("Beam", part)
    beam.FaceCamera = true
    beam.Color = ColorSequence.new({
		ColorSequenceKeypoint.new(0, Color3.fromRGB(13, 105, 172)),
		ColorSequenceKeypoint.new(1, Color3.fromHSV(tick()%4/5,1,1)),
    })

    beam.Attachment0 = attachment0
    beam.Attachment1 = attachment1
	beam.LightEmission = 1.5
    beam.LightInfluence = 1.5
    beam.Width0 = 3
    beam.Width1 = 3
    beam.Texture = "http://www.roblox.com/asset/?id=446111271"
    beam.TextureSpeed = 0.6
    beam.TextureLength = 10
    beam.ZOffset = -1 
	beam.TextureMode = Enum.TextureMode.Wrap

    delay(2, function()
        for i = 0.5, 1, 0.02 do
            wait()
            beam.Transparency = NumberSequence.new(i)
        end
        part:Destroy()
    end)
end

-- Check if the target is in forcefield
local function isInForcefield(character)
    return character:FindFirstChildOfClass("ForceField") ~= nil
end

-- Check if the target is alive
local function isAlive(character)
    local humanoid = character:FindFirstChild("Humanoid")
    return humanoid and humanoid.Health > 0
end

-- Define raycast parameters once for efficiency
local raycastParams = RaycastParams.new()
raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
raycastParams.IgnoreWater = true

-- Caching the player's character to avoid repeated lookups
local playerCharacter = localPlayer.Character

-- Function to check if the target is visible
local function isTargetVisible(gunPosition, target)
    local direction = (target.Position - gunPosition).Unit
    local distance = (target.Position - gunPosition).Magnitude
    
    -- Only update the filter if the player's character changes
    if raycastParams.FilterDescendantsInstances[1] ~= playerCharacter then
        raycastParams.FilterDescendantsInstances = {playerCharacter}
    end
    
    -- Cast the ray
    local result = Workspace:Raycast(gunPosition, direction * distance, raycastParams)

    -- If there's a hit, check if it's part of the target
    if result then
        return result.Instance:IsDescendantOf(target.Parent)
    else
        return true -- No obstruction, target is visible
    end
end



-- Initialize the necessary variables and tables
local whitelistedPlayersAutoshoot = {}
local selectedPlayers = {}  -- For storing the players selected from the dropdown

local function GetClosestTarget(originPosition, maxDistance, isKillAura)
    local closestTarget = nil
    maxDistance = maxDistance or 100
    local KillAuraChars = {}

    -- Function to check if the target is alive
    local function isAlive(character)
        return character and character:FindFirstChild("Humanoid") and character.Humanoid.Health > 0
    end

    -- Separate NPC target finding for regular and KillAura
    if (not isKillAura and BlackoutSettings.ToggleNPCs) or (isKillAura and BlackoutSettings.KillAuraNPCs) then
        local npcGroups = {
            Workspace.NPCs.Hostile,
            Workspace.NPCs.Custom,
            Workspace.WaveSurvival.NPCs
        }

        LPH_NO_VIRTUALIZE(function()
            for _, group in ipairs(npcGroups) do
                if group and group:IsA("Folder") then
                    for _, npc in ipairs(group:GetChildren()) do
                        local targetPart = npc:FindFirstChild('Head')
                        if targetPart and isAlive(npc) then
                            local distanceToNPC = (targetPart.Position - originPosition).Magnitude
                            if distanceToNPC < maxDistance then
                                maxDistance = distanceToNPC
                                closestTarget = targetPart
                                if isKillAura then table.insert(KillAuraChars, npc) end
                            end
                        end
                    end
                end
            end
        end)()

        -- Recursive function to find heads in folders
        local function findHeadsInFolder(folder)
            for _, child in ipairs(folder:GetChildren()) do
                if child:IsA("Folder") then
                    findHeadsInFolder(child)
                elseif child:IsA("Model") then
                    local headPart = child:FindFirstChild("Head")
                    if headPart and isAlive(child) then
                        local distanceToTask = (headPart.Position - originPosition).Magnitude
                        if distanceToTask < maxDistance then
                            maxDistance = distanceToTask
                            closestTarget = headPart
                            if isKillAura then table.insert(KillAuraChars, child) end
                        end
                    end
                end
            end
        end

        -- Check for ActiveTasks folder
        local activeTasks = workspace:FindFirstChild("ActiveTasks")
        if activeTasks then
            LPH_NO_VIRTUALIZE(function()
                for _, folder in ipairs(activeTasks:GetChildren()) do
                    if folder:IsA("Folder") then
                        findHeadsInFolder(folder)
                    end
                end
            end)()

            -- Check for Location folder in ActiveTasks
            local activeTasksLocation = activeTasks:FindFirstChild("Location")
            if activeTasksLocation then
                LPH_NO_VIRTUALIZE(function()
                    for _, enemyName in pairs(activeTasksLocation:GetChildren()) do
                        local headPart = enemyName:FindFirstChild("Head")
                        if headPart and isAlive(enemyName) then
                            local distanceToTask = (headPart.Position - originPosition).Magnitude
                            if distanceToTask < maxDistance then
                                maxDistance = distanceToTask
                                closestTarget = headPart
                                if isKillAura then table.insert(KillAuraChars, enemyName) end
                            end
                        end
                    end
                end)()

                -- Check for AliveEnemies folder in Location
                local aliveEnemies = activeTasksLocation:FindFirstChild("AliveEnemies")
                if aliveEnemies then
                    LPH_NO_VIRTUALIZE(function()
                        for _, enemy in ipairs(aliveEnemies:GetChildren()) do
                            local headPart = enemy:FindFirstChild("Head")
                            if headPart and isAlive(enemy) then
                                local distanceToEnemy = (headPart.Position - originPosition).Magnitude
                                if distanceToEnemy < maxDistance then
                                    maxDistance = distanceToEnemy
                                    closestTarget = headPart
                                    if isKillAura then table.insert(KillAuraChars, enemy) end
                                end
                            end
                        end
                    end)()
                end
            end
        end

        -- Check for Arena folder
        local arena = workspace:FindFirstChild("Arena")
        if arena then
            LPH_NO_VIRTUALIZE(function()
                for _, character in ipairs(arena:GetChildren()) do
                    if character:IsA("Model") then
                        local headPart = character:FindFirstChild("Head")
                        if headPart and isAlive(character) then
                            local distanceToArena = (headPart.Position - originPosition).Magnitude
                            if distanceToArena < maxDistance then
                                maxDistance = distanceToArena
                                closestTarget = headPart
                                if isKillAura then table.insert(KillAuraChars, character) end
                            end
                        end
                    end
                end
            end)()
        end
    end

    -- Separate player target finding for regular and KillAura
    if (not isKillAura and BlackoutSettings.TogglePlayers) or (isKillAura and BlackoutSettings.KillAuraPlayers) then
        LPH_NO_VIRTUALIZE(function()
            for _, player in ipairs(Players:GetPlayers()) do
                if player ~= localPlayer and player.Character and not whitelistedPlayersAutoshoot[player.Name] then
                    local targetPart = player.Character:FindFirstChild('Head')
                    if targetPart and isAlive(player.Character) and not isInForcefield(player.Character) then
                        local distanceToPlayer = (targetPart.Position - originPosition).Magnitude
                        if distanceToPlayer < maxDistance then
                            maxDistance = distanceToPlayer
                            closestTarget = targetPart
                            if isKillAura then table.insert(KillAuraChars, player.Character) end
                        end
                    end
                end
            end
        end)()
    end

    return isKillAura and KillAuraChars or closestTarget
end

















local function shootTarget(origin, target)
    local gunModel = localPlayer.Character:FindFirstChild("ServerGunModel")
    if not gunModel then return end

    local gunBody = gunModel:FindFirstChild("Body") or gunModel:FindFirstChild("Base")
    if not gunBody or not gunBody:IsA("BasePart") then return end

    local gunPosition = gunBody.Position

    -- Determine the part to shoot at
    local hitPart = target.Parent:FindFirstChild('Head') -- Use the configured hit part
    if not hitPart then return end  -- Exit if the specified part doesn't exist

    local args = {gunPosition, CFrame.new(gunPosition, hitPart.Position), 1, 1, math.huge, math.huge}
    
    -- Fire the shoot event
    shootEvent:FireServer(unpack(args))

    -- Fire the hit event for the specified hit part
    hitEvent:FireServer(hitPart, math.huge)
        -- Visualize the bullet if bullet tracers are enabled
		if BlackoutSettings.BulletTracers then
			visualizeBullet(origin, hitPart.Position)
		end
		if BlackoutSettings.AudibilizeShots then 
			gunModel.WeaponRootPart.Fire:Play()
		end
end

-- Wallbang target
local function wallbangTarget(origin, target)
    shootTarget(origin, target)
    print("Shot fired through wall at target:", target.Position)
end
local RunService = game:GetService("RunService")

-- Tracer setup
local tracer = Drawing and Drawing.new("Line") or nil
if tracer then
    tracer.Thickness = 1.3
    tracer.Color = Color3.fromRGB(255, 0, 0) -- Red by default
    tracer.Visible = false
end

-- Update tracer
local function updateTracer(target, isVisible, inWallbangRadius, noAmmo)
    LPH_NO_VIRTUALIZE(function()
        if not tracer then return end

        if target and gunStatus then
            local targetPart = target.Parent:FindFirstChild('Head') -- Find the target part
            if targetPart then
                local targetPosition = Workspace.CurrentCamera:WorldToViewportPoint(targetPart.Position)
                if targetPosition.Z > 0 then
                    local screenCenter = Vector2.new(Workspace.CurrentCamera.ViewportSize.X / 2, Workspace.CurrentCamera.ViewportSize.Y / 2)
                    tracer.From = screenCenter
                    tracer.To = Vector2.new(targetPosition.X, targetPosition.Y)

                    if noAmmo then
                        tracer.Color = Color3.fromRGB(255, 165, 0) -- Orange when no ammo
                    elseif inWallbangRadius then
                        tracer.Color = Color3.fromRGB(0, 255, 0) -- Green in wallbang range
                    elseif isVisible then
                        tracer.Color = Color3.fromRGB(0, 255, 0) -- Green when visible
                    else
                        tracer.Color = Color3.fromRGB(255, 0, 0) -- Red when not visible
                    end
                    tracer.Visible = true
                else
                    tracer.Visible = false -- Hide tracer if target is behind
                end
            else
                tracer.Visible = false -- Hide tracer if no target part found
            end
        else
            tracer.Visible = false -- Hide tracer if no target or no gun status
        end
    end)()
end

-- Main Target Check Function (including cooldown, forcefield, alive checks, and tracer handling)
local function CheckTarget()
    LPH_NO_VIRTUALIZE(function()
        local currentTime = tick()
        if currentTime - lastShotTime < shootCooldown then
            return -- Exit if the cooldown isn't finished
        end

        -- Check gun status before proceeding
        local gunCheckResult = checkGunStatus()
        if gunCheckResult == "no_ammo" then
            updateTracer(nil, false, false, true)
            return
        elseif not gunCheckResult then
            updateTracer(nil, false, false, false)
            return
        end

        local gunPosition = gunStatus.gunBody.Position
        local closestTarget = GetClosestTarget(gunPosition, BlackoutSettings.AutoshootDistance, false)

        if closestTarget then
            local distanceToTarget = (closestTarget.Position - gunPosition).Magnitude
            local inWallbangRadius = BlackoutSettings.WallbangEnabled and distanceToTarget <= BlackoutSettings.WallbangDistance
            local visible = isTargetVisible(gunPosition, closestTarget)

            updateTracer(closestTarget, visible, inWallbangRadius, false)

            if inWallbangRadius then
                wallbangTarget(gunPosition, closestTarget)
                lastShotTime = currentTime
            elseif visible then
                shootTarget(gunPosition, closestTarget)
                lastShotTime = currentTime
            end
        else
            updateTracer(nil, false, false, false)
        end
    end)()
end


-- Main loop
RunService.RenderStepped:Connect(LPH_NO_VIRTUALIZE(function()
    if BlackoutSettings.Autoshoot then
        CheckTarget()
    else
        -- Hide tracer if autoshoot is off
        if tracer then
            tracer.Visible = false
        end
    end
end))





-- Services
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")

local LocalPlayer = Players.LocalPlayer

-- NPC directories
local waveSurvival_m = game.Workspace:WaitForChild("WaveSurvival").NPCs
local NPCs = workspace:WaitForChild("NPCs")
local Hostile_NPCs = NPCs:WaitForChild("Hostile")
local Other_NPCs = NPCs:WaitForChild("Other")

getgenv().killaura = {}

-- Function for hitting a target
function killaura.swinghit(t, hit)
    if BlackoutSettings.KillAuraHeavy == false then
        ReplicatedStorage.MeleeStorage.Events.Swing:InvokeServer()
    else
        ReplicatedStorage.MeleeStorage.Events.Swing:InvokeServer(true)
    end

    -- Fire the hit event on the chosen hit part
    if BlackoutSettings.HitPart == "Head" then
        ReplicatedStorage.MeleeStorage.Events.Hit:FireServer(hit.Head, hit.Head.Position)
    elseif BlackoutSettings.HitPart == "HumanoidRootPart" then
        ReplicatedStorage.MeleeStorage.Events.Hit:FireServer(hit.HumanoidRootPart, hit.HumanoidRootPart.Position)
    end
end






local function gclosest(MaxDistance)
    local closestCharacter = nil
    MaxDistance = MaxDistance or 5000
    local localPlayerCharacter = LocalPlayer.Character
    if not localPlayerCharacter then return nil end

    local localPlayerRootPart = localPlayerCharacter:FindFirstChild("HumanoidRootPart")
    if not localPlayerRootPart then return nil end

    local localPlayerPosition = localPlayerRootPart.Position
    local KillAuraChars = GetClosestTarget(localPlayerPosition, MaxDistance, true)

    LPH_NO_VIRTUALIZE(function()
        for _, character in pairs(KillAuraChars) do
            local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
            local humanoid = character:FindFirstChild("Humanoid")
            if humanoid and humanoidRootPart and humanoid.Health > 0 then
                local distanceToTarget = (humanoidRootPart.Position - localPlayerPosition).Magnitude
                if distanceToTarget < MaxDistance then
                    MaxDistance = distanceToTarget
                    closestCharacter = character
                end
            end
        end
    end)()

    return closestCharacter
end


-- Kill Aura with wait(0.1)
LPH_NO_VIRTUALIZE(function()
    spawn(function()
        while wait(0.1) do
            if BlackoutSettings.KillAura then
                local closest = gclosest(BlackoutSettings.KillAuraDistance)
                if closest and closest:FindFirstChild(BlackoutSettings.HitPart) then
                    killaura.swinghit(BlackoutSettings.KillAuraHeavy, closest)
                end
            end
        end
    end)
end)()



--[[
-- Main Target Check Function (including cooldown, forcefield, alive checks, and tracer handling)
local function CheckTarget()
    local currentTime = tick()
    if currentTime - lastShotTime < shootCooldown then
        return -- Exit if the cooldown isn't finished
    end

    -- Check gun status before proceeding
    local gunCheckResult = checkGunStatus()
    if gunCheckResult == "no_ammo" then
        -- Tracer turns orange if no ammo
        updateTracer(nil, false, false, true)
        return
    elseif not gunCheckResult then
        -- Hide tracer if no gun or other status issues
        updateTracer(nil, false, false, false)
        return
    end

    local gunPosition = gunStatus.gunBody.Position
    local closestTarget = GetClosestFromGun(gunPosition, BlackoutSettings.AutoshootDistance)
    
    if closestTarget then
        local distanceToTarget = (closestTarget.Position - gunPosition).Magnitude
        local inWallbangRadius = BlackoutSettings.WallbangEnabled and distanceToTarget <= BlackoutSettings.WallbangDistance
        local visible = isTargetVisible(gunPosition, closestTarget)

        updateTracer(closestTarget, visible, inWallbangRadius, false)

        if inWallbangRadius then
            wallbangTarget(gunPosition, closestTarget)
            lastShotTime = currentTime
        elseif visible then
            shootTarget(gunPosition, closestTarget)
            lastShotTime = currentTime
        end
    else
        updateTracer(nil, false, false, false)
    end
end

-- Main loop
RunService.RenderStepped:Connect(function()
    if BlackoutSettings.Autoshoot then
        CheckTarget()
    end
end)




--[[
 -- No recoil

 local NewIndex
NewIndex = hookmetamethod(game, "__newindex", function(self, Property, Value)
    if not checkcaller() then
        -- Prevent camera recoil by locking CFrame
        if BlackoutSettings.NoRecoil and self == workspace.CurrentCamera and Property == "CFrame" then
            -- Traceback to find the recoil update during RenderStepped
            local Traceback = debug.traceback()

            -- If recoil update is detected, lock camera CFrame
            if Traceback:find("RenderSteppedUpdate", 1, true) or Traceback:find("ScreenShake") then
                -- Return the existing CFrame to prevent recoil
                return
            end
        end
    end

    return NewIndex(self, Property, Value)
end)




-- Infinite Stamina

local Namecall
Namecall = hookmetamethod(game, "__namecall", function(self, ...)
    local Args = {...}
    local Method = getnamecallmethod()
    local ExecutorCall = checkcaller()

    if not ExecutorCall then
        -- Hooking GetAttribute method for Stamina
        if BlackoutSettings.InfiniteStamina and Method == "GetAttribute" then
            if Args[1] == "Stamina" then
                return 100
            end
        end

        -- Hooking FireServer method for Stamina
        if Method == "FireServer" then
            if self.Name == "Stamina" then
                return
            end
        end
    end

    return Namecall(self, ...)
end)


]]--
local Namecall
local NewIndex

-- Hook __namecall
Namecall = hookmetamethod(game, "__namecall", LPH_NO_VIRTUALIZE(function(self, ...)
    local Args = {...}
    local Method = getnamecallmethod()
    local ExecutorCall = checkcaller()

    if not ExecutorCall then
        -- Hooking GetAttribute method for Stamina
        if BlackoutSettings.InfiniteStamina and Method == "GetAttribute" then
            if Args[1] == "Stamina" then
                return 100
            end
        end

        -- Hooking FireServer method for Stamina and Damage
        if Method == "FireServer" then
            -- Block Stamina changes
            if self.Name == "Stamina" then
                return
            end

            -- Block fall damage and ragdoll effects
            if BlackoutSettings.NoFallDamage and (self.Name == "Damage" or self.Name == "Ragdoll") then
                return
            end
        end
    end

    return Namecall(self, ...)
end))

-- Hook __newindex
NewIndex = hookmetamethod(game, "__newindex", LPH_NO_VIRTUALIZE(function(self, Property, Value)
    if not checkcaller() then
        if BlackoutSettings.NoRecoil and self == workspace.CurrentCamera and Property == "CFrame" then
            local Traceback = debug.traceback()

            if Traceback:find("RenderSteppedUpdate", 1, true) or Traceback:find("ScreenShake") then
                -- Check for No Recoil
                if BlackoutSettings.NoRecoil then
                    return
                end

                -- Check for Remove Screenshake
                if Traceback:find("ScreenShake") and BlackoutSettings.RemoveScreenshake then
                    return NewIndex(self, Property, workspace.CurrentCamera.CFrame)
                end
            end
        end
    end

    return NewIndex(self, Property, Value)
end))






-- AutoLoot



-- Define necessary services and objects
local ProxPromptService = game:GetService("ProximityPromptService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Client = game.Players.LocalPlayer

-- Proximity prompts handler
ProxPromptService.PromptButtonHoldBegan:Connect(function(Prompt, Player)
    if not BlackoutSettings.AutoLoot then
        return
    end

    -- Ensure the player interacting is the client
    if Player == Client then
        -- Instantly interact with proximity prompts
        fireproximityprompt(Prompt)
    end

    -- Instantly loot cash if the prompt corresponds to a lootable object
    if Prompt.Name == "OpenLootTable" and Prompt.Parent:FindFirstChild("LootTable") then
        ReplicatedStorage.Events.Loot.LootObject:FireServer(Prompt.Parent:FindFirstChild("LootTable"), "Cash")
        ReplicatedStorage.Events.Loot.LootObject:FireServer(Prompt.Parent:FindFirstChild("LootTable"), "Valuables")
    end
end)





-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local LocalPlayer = Players.LocalPlayer

-- Variables for flying
local flying = false
local speed = 50 -- Adjust the fly speed
local flyLoop
local character
local humanoidRootPart
local humanoid

-- Reuse BodyVelocity and BodyGyro objects
local BodyVelocity = Instance.new("BodyVelocity")
BodyVelocity.MaxForce = Vector3.new(100000, 100000, 100000)

local BodyGyro = Instance.new("BodyGyro")
BodyGyro.MaxTorque = Vector3.new(100000, 100000, 100000)
BodyGyro.P = 3000

-- Variables for spoofing death animation
local Anim = Instance.new("Animation")
Anim.AnimationId = "rbxassetid://181526230"
local track

-- Function to setup lockpick functionality
local function setupLockpick()
    local Module
    LPH_NO_VIRTUALIZE(function()
        for _, Value in next, getgc(true) do 
            if type(Value) == "table" and rawget(Value, "Lockpick") and type(rawget(Value, "Lockpick")) == "function" then 
                Module = Value
                break
            end
        end 
    end)()

    local Lockpick = Module.Lockpick

    Module.Lockpick = LPH_NO_VIRTUALIZE(function(...)
        if not BlackoutSettings.AutoLockpick then
            return Lockpick(...)
        end
        
        -- Instantly complete the lockpick minigame
        ReplicatedStorage.Events.Loot.MinigameResult:FireServer(select(2, ...), true)
        task.wait(0.4)
        keypress(0x45)  -- Simulates pressing the "E" key
        return Lockpick(...)
    end)
end

-- Function to setup character on respawn
local function setupCharacter(newCharacter)
    character = newCharacter
    humanoidRootPart = character:WaitForChild("HumanoidRootPart")
    humanoid = character:WaitForChild("Humanoid") -- Wait for the Humanoid to be available

    -- Load the animation for spoofing death
    track = humanoid:LoadAnimation(Anim)

    -- Resume flying if it was enabled before death
    if flying then
        BodyVelocity.Parent = humanoidRootPart -- Attach velocity when flying starts
        BodyGyro.Parent = humanoidRootPart -- Attach gyro to maintain orientation
    end

    setupLockpick()  -- Set up lockpick functionality for this character
end

-- Function to toggle flying
local function setFlyState(enable)
    flying = enable
    BodyVelocity.Parent = enable and humanoidRootPart or nil
    BodyGyro.Parent = enable and humanoidRootPart or nil

    if enable then
        flyLoop = LPH_NO_VIRTUALIZE(function()
            return RunService.Heartbeat:Connect(function()
                local moveDirection = Vector3.new()
                if UserInputService:IsKeyDown(Enum.KeyCode.W) then
                    moveDirection = moveDirection + workspace.CurrentCamera.CFrame.LookVector
                end
                if UserInputService:IsKeyDown(Enum.KeyCode.S) then
                    moveDirection = moveDirection - workspace.CurrentCamera.CFrame.LookVector
                end
                if UserInputService:IsKeyDown(Enum.KeyCode.A) then
                    moveDirection = moveDirection - workspace.CurrentCamera.CFrame.RightVector
                end
                if UserInputService:IsKeyDown(Enum.KeyCode.D) then
                    moveDirection = moveDirection + workspace.CurrentCamera.CFrame.RightVector
                end

                -- Apply velocity based on input
                BodyVelocity.Velocity = moveDirection * speed
                BodyGyro.CFrame = workspace.CurrentCamera.CFrame -- Maintain character orientation
            end)
        end)()
    else
        if flyLoop then flyLoop:Disconnect() end
    end
end

-- Connect the CharacterAdded event to setup the humanoid and lockpick for the player
LocalPlayer.CharacterAdded:Connect(setupCharacter)

-- Handle current character
if LocalPlayer.Character then
    setupCharacter(LocalPlayer.Character)
end

-- Function to toggle flying on pressing F
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if input.KeyCode == Enum.KeyCode.F and not gameProcessed and BlackoutSettings.Fly then
        setFlyState(not flying) -- Toggle flying state
    end
end)


-- Settings
local Settings = {
    GroupId = 6568965,
    KickOnDetection = false,
    NotifyOnDetection = true,
    DetectionEnabled = true
}

-- Sound when a staff member is detected
local AdminSound = Instance.new("Sound")
AdminSound.SoundId = "rbxassetid://7518627362"  -- Sound ID
AdminSound.Parent = game.Workspace

-- Function to check if a player is in a group
local function IsInGroup(Plr, Id)
    local Success, Response = pcall(function() return Plr:IsInGroup(Id) end)
    return Success and Response
end

-- Function to get the player's role in the group
local function GetRoleInGroup(Plr, Id)
    local Success, Response = pcall(function() return Plr:GetRoleInGroup(Id) end)
    return Success and Response or nil
end

-- Function to get the group's role hierarchy
local function GetGroupRoles(Id)
    local Success, Roles = pcall(function() return game:GetService("GroupService"):GetRoles(Id) end)
    return Success and Roles or nil
end

-- Function to handle when a player joins the game
local function OnPlayerJoin(Plr)
    -- Check if detection is enabled
    if Settings.DetectionEnabled then
        if IsInGroup(Plr, Settings.GroupId) then
            local Role = GetRoleInGroup(Plr, Settings.GroupId)
            local Roles = GetGroupRoles(Settings.GroupId)

            if Roles then
                local FirstRole = Roles[1]  -- Assuming the first role is the lowest

                if Role and Role.Id > FirstRole.Id then  -- Check if player's role is higher than the first role
                    -- Play sound and notify or kick the player based on settings
                    if Settings.KickOnDetection then
                        game.Players.LocalPlayer:Kick("[Kinetic] - An Administrator has joined your game.")
                    elseif Settings.NotifyOnDetection then
                        AdminSound:Play()
                        game.StarterGui:SetCore("SendNotification", {
                            Title = "Kinetic",
                            Text = "Admin Detected: " .. Plr.Name,
                            Icon = "rbxassetid://88195615011513",  -- Notification icon
                            Duration = 7,
                        })
                    end
                end
            end
        end
    end
end

-- Connect the PlayerAdded event to the OnPlayerJoin function
game.Players.PlayerAdded:Connect(OnPlayerJoin)









-- Teleport to closest:

-- Tween Teleport to Closest Broker NPC

-- Parameters











-- // Start // --


--// Original Size UI //--

--local AlaskaModule = loadstring(game:HttpGet("https://raw.githubusercontent.com/NougatBitz/AlaskaEternal/main/UI"))()








--// Modified UI //--
local AlaskaModule = loadstring(game:HttpGet("https://raw.githubusercontent.com/nullputr-web/haggdgweqf/refs/heads/main/anothertestlololol"))()
local Library = AlaskaModule.new({
    Title = "",
    Icon = "rbxassetid://0",
    Parent = game.CoreGui,
    ToggleKey = Enum.KeyCode.LeftAlt
})




-- // Tabs // --

-- // Tabs // --

local VisualsTab = Library.Tabs.new({
    Title = "Visuals",
    Icon = "rbxassetid://10403490626"
})

local CombatTab = Library.Tabs.new({
    Title = "Weapon",
    Icon = "rbxassetid://132485648552802"
})
--rbxassetid://10401329089



local ExploitsTab = Library.Tabs.new({
    Title = "Exploits",
    Icon = "rbxassetid://116424921513573"

})


local MiscTab = Library.Tabs.new({
    Title = "Misc",
    Icon = "rbxassetid://112253400449843"
})



-- // Visuals Tab Start // --


-- // Player Esp // --




local VisualsTab2 = VisualsTab:Groupbox({
    Title = "Player Visuals",
    Side = 1
})


local WorldEspTab = VisualsTab:Groupbox({
    Title = "World Visuals",
    Side = 2
})





VisualsTab2:CreateObject(function(Type, Flag, Value, Selected)
	Esp.PlayerUtils.Settings.General.EspOn = Value
	end, {
		{
		Type = "Toggle",
		Default = false,
		Flag = "Toggle"
	}, {
		Type = "Label",
		Text = "Toggle Esp"
	},
	})
	
	VisualsTab2:CreateObject(function(Type, Flag, Value, Selected)
		Esp.PlayerUtils.Settings.Tag.Enabled = Value
		end, {
			{
			Type = "Toggle",
			Default = false,
			Flag = "Toggle"
		}, {
			Type = "Label",
			Text = "Show Info"
		},
		})
	
		VisualsTab2:CreateObject(function(Type, Flag, Value, Selected)
			Esp.PlayerUtils.Settings.Box.Enabled = Value
			end, {
				{
				Type = "Toggle",
				Default = false,
				Flag = "Toggle"
			}, {
				Type = "Label",
				Text = "Show Box"
			},
			})
	
	
			VisualsTab2:CreateObject(function(Type, Flag, Value, Selected)
		Esp.PlayerUtils.Settings.Health.Enabled = Value
		end, {
			{
			Type = "Toggle",
			Default = false,
			Flag = "Toggle"
		}, {
			Type = "Label",
			Text = "Show Healthbar"
		},
		})
	
		
		
		VisualsTab2:CreateObject(function(Type, Flag, Value, Selected)
			Esp.PlayerUtils.Settings.General.MaxDistance = Value
               end, {
                {
               Type = "Slider",
               Min = 1,
               Max = 1500,
               Default = 500,
               DecimalPlaces = 1,
               Format = "%s",
               Flag = "Distance"
            }, {
               Type = "Label",
               Text = "Render Distance"
            }
               })


			
	
			   WorldEspTab:CreateObject(function(Type, Flag, Value, Selected)
			BlackoutSettings.Fullbright = Value
				end, {
					{
					Type = "Toggle",
					Default = false,
					Flag = "Toggle"
				}, {
					Type = "Label",
					Text = "Enable Fullbright"
				},
				})
	
	

	
  -- // Silent Aim Tab // --

  local CombatTabR = CombatTab:Groupbox({
    Title = "Aimbot",
    Side = 1
})

CombatTabR:CreateObject(function(Type, Flag, Value, Selected)
BlackoutSettings.SilentAimEnabled = Value
    end, {
        {
        Type = "Toggle",
        Default = false,
        Flag = "Toggle"
    }, {
        Type = "Label",
        Text = "Enable Silent Aim"
    }
    })


    CombatTabR:CreateObject(function(Type, Flag, Value, Selected)
        BlackoutSettings.SilentAimFOVEnabled = Value
        end, {
            {
            Type = "Toggle",
            Default = false,
            Flag = "Toggle"
        }, {
            Type = "Label",
            Text = "Show FOV"
    },
        })

        CombatTabR:CreateObject(function(Type, Flag, Value, Selected)
			BlackoutSettings.SilentAimRadius = Value
               end, {
                {
               Type = "Slider",
               Min = 50,
               Max = 1000,
               Default = 150,
               DecimalPlaces = 1,
               Format = "%s",
               Flag = "Distance"
            }, {
               Type = "Label",
               Text = "FOV Size"
            }
               })

               CombatTabR:CreateObject(function(Type, Flag, Value, Selected)
                BlackoutSettings.SilentAimHitChance = Value
                   end, {
                    {
                   Type = "Slider",
                   Min = 0,
                   Max = 100,
                   Default = 100,
                   DecimalPlaces = 1,
                   Format = "%s",
                   Flag = "Hitchance"
                }, {
                   Type = "Label",
                   Text = "Hitchance"
                }
                   })


                   CombatTabR:CreateObject(function(Type, Flag, Value, Selected)
					BlackoutSettings.SilentAimTargetPart = Value
                    end, {
                        {
                   Type = "Dropdown",
                   Text = "Head",
                   Items = {
                    "Head",
                    "HumanoidRootPart",
                    'Random'
                },
                Defaults = {
                    [1] = true,
                },
                Default = 1,
                SelectMultiple = false,
                CloseAfterSelection = true,
                NoStartCallback = true
            }
                    })
		
-- Modifications


	local CombatTab3 = CombatTab:Groupbox({
						Title = "Weapon Modifications",
					Side = 2
					})

		


					CombatTab3:CreateObject(function(Type, Flag, Value, Selected)
						BlackoutSettings.NoRecoil = Value
						end, {
							{
							Type = "Toggle",
							Default = false,
							Flag = "Toggle"
						}, {
							Type = "Label",
							Text = "Full No Recoil"
						}
						})



						CombatTab3:CreateObject(function(Type, Flag, Value, Selected)
							BlackoutSettings.LowerRecoil = Value
							end, {
								{
								Type = "Toggle",
								Default = false,
								Flag = "Toggle"
							}, {
								Type = "Label",
								Text = "Lower Recoil"
							}
							})
	
									
			

							CombatTab3:CreateObject(function(Type, Flag, Value, Selected)
								BlackoutSettings.NoSpread = Value
								end, {
									{
									Type = "Toggle",
									Default = false,
									Flag = "Toggle"
								}, {
									Type = "Label",
									Text = "No Spread"
								}
								})
				
										
				
								CombatTab3:CreateObject(function(Type, Flag, Value, Selected)
									BlackoutSettings.FastShoot = Value
									end, {
										{
										Type = "Toggle",
										Default = false,
										Flag = "Toggle"
									}, {
										Type = "Label",
										Text = "Fast Shoot"
									}
									})
	
									CombatTab3:CreateObject(function(Type, Flag, Value, Selected)
										firerate = Value
													end, {
														{
																			Type = "Label",
																			Text = "Shoot Speed"
																		   
																		}, {
													
															
														   Type = "Slider",
														   Min = 0,
														   Max = 9999,
														   Default = 500,
														   DecimalPlaces = 1,
														   Format = "%s",
														   Flag = "Distance"
														
														
														}
														   })
														   CombatTab3:CreateObject(function(Type, Flag, Value, Selected)
															BlackoutSettings.BulletsPerShot = Value
															end, {
																{
																Type = "Toggle",
																Default = false,
																Flag = "Toggle"
															}, {
																Type = "Label",
																Text = "Bullets Per Shot"
															}
															})
							
	
	
							CombatTab3:CreateObject(function(Type, Flag, Value, Selected)
				bps = Value
							end, {
								{
													Type = "Label",
													Text = "BPS Value:"
												   
												}, {
							
									
								   Type = "Slider",
								   Min = 1,
								   Max = 250,
								   Default = 15,
								   DecimalPlaces = 1,
								   Format = "%s",
								   Flag = "Distance"
								
								}, {
									Type = "Information",
									Text = "[!] Feature may crash your client it is heavy both on server and client!"
								
								}
								   })
						
								
							
			



-- Melee

  local CombatTab2 = CombatTab:Groupbox({
    Title = "Automatic Melee Exploits",
    Side = 2
})

CombatTab2:CreateObject(function(Type, Flag, Value, Selected)
    BlackoutSettings.KillAura = Value
    end, {
        {
        Type = "Toggle",
        Default = false,
        Flag = "Toggle"
    }, {
        Type = "Label",
        Text = "Kill Aura"
    }, {
		Type = "Dropdown",
		Text = "Head",
		Items = {
			"Head",
			"HumanoidRootPart",
		},
		Defaults = {
			[1] = true,
		},
		Default = 1,
		SelectMultiple = false,
		CloseAfterSelection = true,
		NoStartCallback = true,
		Callback = function(Type, Flag, Value, Selected)
			BlackoutSettings.HitPart = Value
		end
	}
    })




	CombatTab2:CreateObject(function(Type, Flag, Value, Selected)
		BlackoutSettings.KillAuraDistance = Value
	end, {
		{
							Type = "Label",
							Text = "Target distance:"
						   
						}, {
	
			
		   Type = "Slider",
		   Min = 1,
		   Max = 15,
		   Default = 15,
		   DecimalPlaces = 1,
		   Format = "%s",
		   Flag = "Distance"
		}
		   })



		


		   CombatTab2:CreateObject(function(Type, Flag, Value, Selected)
			BlackoutSettings.KillAuraHeavy = Value
			end, {
				{
				Type = "Toggle",
				Default = false,
				Flag = "Toggle"
			}, {
				Type = "Label",
				Text = "Use Heavy Attacks"
			}
			})





			CombatTab2:CreateObject(function(Type, Flag, Value, Selected)
				BlackoutSettings.KillAuraPlayers = Value
				end, {
					{
					Type = "Toggle",
					Default = false,
					Flag = "Toggle"
				}, {
					Type = "Label",
					Text = "Target Players"
				}
				})
	
	
				CombatTab2:CreateObject(function(Type, Flag, Value, Selected)
					BlackoutSettings.KillAuraNPCs = Value
					end, {
						{
						Type = "Toggle",
						Default = false,
						Flag = "Toggle"
					}, {
						Type = "Label",
						Text = "Target NPCs"
					}
					})

			

	
			local CombatTab3 = CombatTab:Groupbox({
				Title = "Auto Shoot",
				Side = 1
			})

			CombatTab3:CreateObject(function(Type, Flag, Value, Selected)
				BlackoutSettings.Autoshoot = Value
				end, {
					{
					Type = "Toggle",
					Default = false,
					Flag = "Toggle"
				}, {
					Type = "Label",
					Text = "Auto Shoot"
				},

					{
						Type = "Information",
					Text = "Autoshoot is recommended to be used on good ping, due to blackout being very heavily ping based, some shots may not register. For the best performance, low ping is recommended.\n\nIf the autoshoot tracer does not show up anymore, that indicates that the server-side ammo is 0. Please shoot one shot from your weapon and then reload. "
					},

					{
					Type = "Dropdown",
					Text = "Head",
					Items = {
						"Head",
						"HumanoidRootPart",
					},
					Defaults = {
						[1] = true,
					},
					Default = 1,
					SelectMultiple = false,
					CloseAfterSelection = true,
					NoStartCallback = true,
					Callback = function(Type, Flag, Value, Selected)
						--BlackoutSettings.AutoshootHitPart = Value
					end
				}
			})
			




									
				CombatTab3:CreateObject(function(Type, Flag, Value, Selected)
					shootCooldown = Value
				end, {
					{
										Type = "Label",
										Text = "Time between shots:"
									   
									}, {
				
					   Type = "Slider",
					   Min = 0,
					   Max = 1,
					   Default = 0.04,
					   DecimalPlaces = 2,
					   Format = "%s",
					   Flag = "Distance"
					}
					   })


					   CombatTab3:CreateObject(function(Type, Flag, Value, Selected)
    
				
						
						-- Enable settings based on the Value
						if Value == "Penetrable" then
							BlackoutSettings.WallbangEnabled = true
						elseif Value == "Visible" then
							BlackoutSettings.WallbangEnabled = false
						end
					
					end, {
						{
							Type = "Dropdown",
							Text = "Select Fire Mode:",
							Items = {
								"Visible",
								"Penetrable"
							},
							Defaults = {
								[1] = true,
							},
							Default = 1,
							SelectMultiple = false,  -- Ensures only one option can be selected at a time
							CloseAfterSelection = true,
							NoStartCallback = true
						},
						{
							Type = "Information",
							Text = "Fire Mode - Controls the conditions in which you will autoshoot.\n\nVisible - Will shoot the enemy if they are visible.\n\nPenetrable - Will shoot enemies through walls, but sometimes can miss some shots if the penetration distance is set to a high value, 45 is recommended. Tweak if needed."
						}
					})
											





				CombatTab3:CreateObject(function(Type, Flag, Value, Selected)
		
					end, {
						{
						Type = "Toggle",
						Default = true,
						Flag = "Toggle"
					}, {
						Type = "Label",
						Text = "Decrease Ammo"
					}, {
				
						Type = "Information",
						Text = "[AUTO-TOGGLED] Manipulates the serverside bullets. When toggling the feature, your weapon will shoot multiple bullets but it will take way less ammo from your actual magazine. It is heavily recommended to keep this feature toggled on at all times. "
					}
					})



									
				CombatTab3:CreateObject(function(Type, Flag, Value, Selected)
					BlackoutSettings.AutoshootDistance = Value
					   end, {
	{
						Type = "Label",
						Text = "Target distance:"
					   
					}, {

					   Type = "Slider",
					   Min = 50,
					   Max = 5000,
					   Default = 350,
					   DecimalPlaces = 1,
					   Format = "%s",
					   Flag = "Distance"
					}
					   })


			
					   CombatTab3:CreateObject(function(Type, Flag, Value, Selected)
						BlackoutSettings.WallbangDistance = Value
					end, {
						{
											Type = "Label",
											Text = "Penetration distance:"
										   
										}, {
						   Type = "Slider",
						   Min = 1,
						   Max = 100,
						   Default = 25,
						   DecimalPlaces = 1,
						   Format = "%s",
						   Flag = "Distance"
				
						}
						   })

			
			



										

									CombatTab3:CreateObject(function(Type, Flag, Value, Selected)
										BlackoutSettings.TogglePlayers = Value
										end, {
											{
											Type = "Toggle",
											Default = false,
											Flag = "Toggle"
										}, {
											Type = "Label",
											Text = "Target Players"
										}
										})
			

								


										CombatTab3:CreateObject(function(Type, Flag, Value, Selected)
											BlackoutSettings.ToggleNPCs = Value
											end, {
												{
												Type = "Toggle",
												Default = false,
												Flag = "Toggle"
											}, {
												Type = "Label",
												Text = "Target NPCs"
											}
											})
				

									CombatTab3:CreateObject(function(Type, Flag, Value, Selected)
							BlackoutSettings.BulletTracers = Value
							end, {
								{
								Type = "Toggle",
								Default = false,
								Flag = "Toggle"
							}, {
								Type = "Label",
								Text = "Visualize Fired Shots"
							}
							})


							CombatTab3:CreateObject(function(Type, Flag, Value, Selected)

							BlackoutSettings.AudibilizeShots = Value
						end, {
							{
							Type = "Toggle",
							Default = true,
							Flag = "Toggle"
						}, {
							Type = "Label",
							Text = "Audibilize Fired Shots"
						}
						})
		--[[		
			
						local CombatTab5 = CombatTab:Groupbox({
							Title = "ForceFire",
							Side = 2
						})
						
						CombatTab5:CreateObject(function(Type, Flag, Value, Selected)

			
						end, {
							{
							Type = "Toggle",
							Default = false,
							Flag = "Toggle"
						}, {
							Type = "Label",
							Text = "Enable Force-Fire"
						}
						})

						CombatTab5:CreateObject(function(Type, Flag, Value, Selected)
			
						end, {
							{
							Type = "Label",
							Text = "Time between shots:"
											   
											}, {
						
							   Type = "Slider",
							   Min = 0,
							   Max = 1,
							   Default = 0.04,
							   DecimalPlaces = 2,
							   Format = "%s",
							   Flag = "Distance"
							}
							   })

			]]
							local ExploitsTab2 = ExploitsTab:Groupbox({
								Title = "Behavior Modifications",
								Side = 1
							})


							
							ExploitsTab2:CreateObject(function(Type, Flag, Value, Selected)
								BlackoutSettings.AutoReload = Value
								end, {
									{
									Type = "Toggle",
									Default = false,
									Flag = "Toggle"
								}, {
									Type = "Label",
									Text = "Automatic Reload"
								},

								{
									Type = "Information",
									Text = "This feature has been removed from testing build."
								}
								})
						

							ExploitsTab2:CreateObject(function(Type, Flag, Value, Selected)
				
								end, {
									{
									Type = "Toggle",
									Default = false,
									Flag = "Toggle"
								}, {
									Type = "Label",
									Text = "Automatic Finish"
								},

								{
									Type = "Information",
									Text = "This feature has been removed from testing build."
								}
								})



								ExploitsTab2:CreateObject(function(Type, Flag, Value, Selected)
									-- You can handle the selected player here if needed
								end, {
									{
										Type = "Dropdown",
										Text = "Select Target:",
										
										-- Dynamically populate the Items list with the player names
										Items = (function()
											local playerList = {}
											local localPlayer = game.Players.LocalPlayer
								
											for _, player in ipairs(game.Players:GetPlayers()) do
												if player ~= localPlayer then  -- Exclude the local player
													table.insert(playerList, player.Name)
												end
											end
								
											return playerList
										end)(),
								
										Defaults = {
											[1] = true,
										},
										Default = 1,
										SelectMultiple = false,
										CloseAfterSelection = true,
										NoStartCallback = true
									},
								
								})
								
								ExploitsTab2:CreateObject(function(Type, Flag, Value, Selected)
									-- You can handle the selected player here if needed
								end, {
	
								{
									Type = "Button",
									Flag = "Nutonme"
								}, {
									Type = "Label",
									Text = "Teleport Throwable"
								}, {
										Type = "Information",
										Text = "This feature has been removed from testing build."
									}
								})




					
								local CharacterTab2 = ExploitsTab:Groupbox({
									Title = "Character Exploits",
									Side = 1
								})
		
		
								CharacterTab2:CreateObject(function(Type, Flag, Value, Selected)
									BlackoutSettings.InfiniteStamina = Value
									end, {
										{
										Type = "Toggle",
										Default = false,
										Flag = "Toggle"
									}, {
										Type = "Label",
										Text = "Exploit Stamina"
									}
									})

									CharacterTab2:CreateObject(function(Type, Flag, Value, Selected)
										if Flag == "Toggle" then
											BlackoutSettings.Fly = Value -- This sets the Fly toggle value
										elseif Flag == "Distance" then
											speed = Value -- This sets the speed value from the slider
										end
									end, {
										{
											Type = "Toggle",
											Default = false,
											Flag = "Toggle"
										},
										{
											Type = "Label",
											Text = "Player Fly"
										},
										{
											Type = "Slider",
											Min = 0,
											Max = 150,
											Default = 15,
											DecimalPlaces = 1,
											Format = "%s",
											Flag = "Distance"
									
											}, {
											Type = "Information",
											Text = "This feature is toggled by the keybind F. Custom keybinds will be added in the public build."
										}
									})
									
							


									CharacterTab2:CreateObject(function(Type, Flag, Value, Selected)
										BlackoutSettings.Noclip = Value
										end, {
											{
											Type = "Toggle",
											Default = false,
											Flag = "Toggle"
										}, {
											Type = "Label",
											Text = "Player Noclip"
										}
										
										})
							
										CharacterTab2:CreateObject(function(Type, Flag, Value, Selected)
											NoRagdoll = Value
											end, {
										{
												Type = "Label",
												Text = "    "
											
											}, {
												Type = "Toggle",
												Default = true,
												Flag = "Toggle"
											}, {
												Type = "Label",
												Text = "Exclude Ragdolling"
											}
											
											})
						

										CharacterTab2:CreateObject(function(Type, Flag, Value, Selected)
											if Flag == "Toggle" then
												BlackoutSettings.Walkspeed = Value -- This sets the Walkspeed toggle value
											elseif Flag == "Distance" then
												BlackoutSettings.WalkspeedValue = Value -- This sets the Walkspeed value from the slider
											end
										end, {
											{
												Type = "Toggle",
												Default = false,
												Flag = "Toggle"
											},
											{
												Type = "Label",
												Text = "Player Speed"
											},
											{
												Type = "Slider",
												Min = 1,
												Max = 100,
												Default = 50,
												DecimalPlaces = 1,
												Format = "%s",
												Flag = "Distance"
											}
										})
										
						
						
										   CharacterTab2:CreateObject(function(Type, Flag, Value, Selected)
											BlackoutSettings.InfiniteJump = Value
												end, {
													{
													Type = "Toggle",
													Default = false,
													Flag = "Toggle"
												}, {
													Type = "Label",
													Text = "Infinite Jump"
												}
											})


											CharacterTab2:CreateObject(function(Type, Flag, Value, Selected)
												BlackoutSettings.SelfRevive = Value
											end, {
												{
													Type = "Toggle",
													Default = false,
													Flag = "Toggle"
												}, {
													Type = "Label",
													Text = "Self Revive"
												}, {
													Type = "Information",
													Text = "Revives you automatically once you have been downed, allows you to move around, and heal yourself making it easier not to lose items and collect them later. You cannot shoot, nor interact with anything."
												}
											})
											
						
											CharacterTab2:CreateObject(function(Type, Flag, Value, Selected)
							BlackoutSettings.NoFallDamage = Value
											end, {
												{
												Type = "Toggle",
												Default = false,
												Flag = "Toggle"
											}, {
												Type = "Label",
												Text = "No Fall Damage"
											}
											})
								
								
						
											CharacterTab2:CreateObject(function(Type, Flag, Value, Selected)
												BlackoutSettings.RemoveScreenshake = Value
													end, {
														{
														Type = "Toggle",
														Default = false,
														Flag = "Toggle"
													}, {
														Type = "Label",
														Text = "No Screen Shake"
													}
													})
		
													

													local AntiAim = ExploitsTab:Groupbox({
														Title = "Anti-Aim",
														Side = 2
													})


										
													AntiAim:CreateObject(function(Type, Flag, Value, Selected)
														BlackoutSettings.Jitter = Value
														   end, {
															{
															Type = "Toggle",
															Default = false,
															Flag = "Toggle"
														}, {
															Type = "Label",
															Text = "Enable Fake Angles"
													},
														})
									
														AntiAim:CreateObject(function(Type, Flag, Value, Selected)
													 
															   end, {
									
												   {
														Type = "Label",
														Text = "Mode"
													}, {
														Type = "Dropdown",
														Text = "",
														Items = {
															"Backwards",
															"Front",
															"Force Right",
															"Force Left"
														},
														Defaults = {
															[2] = true, -- "sure :3!!"
															[4] = true -- "mrrp mrrp mrewo mrwooo meoooow ^-^"
														},
														Default = 1,
														SelectMultiple = false,
														CloseAfterSelection = true,
														NoStartCallback = true
													
												}, {
													Type = "Information",
													Text = "Feature has been removed from testing build."
												
												}
													})
									
									
													AntiAim:CreateObject(function(Type, Flag, Value, Selected)
													BlackoutSettings.Angle = Value
														   end, {
															{
													Type = "Slider",
													Min = 0,
													Max = 80,
													Default = 0.0,
													DecimalPlaces = 1,
													Format = "%s",
													Flag = "Yaw"
												}, {
													Type = "Label",
													Text = "Yaw"
												   
												},
											})
									
										AntiAim:CreateObject(function(Type, Flag, Value, Selected)
											BlackoutSettings.Angle = Value	
											end, {
											 {
									 Type = "Slider",
									 Min = 0,
									 Max = 50,
									 Default = 0.0,
									 DecimalPlaces = 1,
									 Format = "%s",
									 Flag = "Pitch"
									
									}, {
									 Type = "Label",
									 Text = "Pitch"
									
									},
									})
									
									AntiAim:CreateObject(function(Type, Flag, Value, Selected)
										BlackoutSettings.Angle = Value			
									end, {
									 {
									Type = "Slider",
									Min = 0,
									Max = 150,
									Default = 0.0,
									DecimalPlaces = 1,
									Format = "%s",
									Flag = "Roll"
									}, {
										Type = "Label",
										Text = "Roll"
									   
									   },
									})

				


									AntiAim:CreateObject(function(Type, Flag, Value, Selected)
										if not humanoid then
											return -- Exit if the character or humanoid is not found
										end
									
										if Value == true then
											-- Load and play the animation when toggled on
											track = humanoid:LoadAnimation(Anim)
											track:Play(.1, 1, 1)
										elseif Value == false then
											-- Stop the animation when toggled off
											if track and track.IsPlaying then
												track:Stop()
											end
										end
									end, {
										{
											Type = "Toggle",
											Default = false,
											Flag = "Toggle"
										}, {
											Type = "Label",
											Text = "Spoof Death"
										}, {
											Type = "Information",
											Text = "Makes you look like you're dead [Server Side], giving you a reach advantage."
										}
									})
									
											


--[[

				   local ExploitsTab3 = ExploitsTab:Groupbox({
					Title = "Server Exploits",
					Side = 2
				})
			
				ExploitsTab3:CreateObject(function(Type, Flag, Value, Selected)
					BlackoutSettings.FlingAll = Value
					end, {
						{
						Type = "Toggle",
						Default = false,
						Flag = "Toggle"
					}, {
						Type = "Label",
						Text = "Fling all"
					}
					})
		
		




					ExploitsTab3:CreateObject(function(Type, Flag, Value, Selected)
						BlackoutSettings.FlingAll = Value
						end, {
							{
							Type = "Toggle",
							Default = false,
							Flag = "Toggle"
						}, {
							Type = "Label",
							Text = "Kill all"
						}
						})
			
			
	
	]]

	



					
											local CharacterTab3 = ExploitsTab:Groupbox({
												Title = "Miscellaneous Exploits",
												Side = 2
											})



											CharacterTab3:CreateObject(function(Type, Flag, Value, Selected)
												BlackoutSettings.AutoLockpick = Value
													end, {
														{
														Type = "Toggle",
														Default = false,
														Flag = "Toggle"
													}, {
														Type = "Label",
														Text = "Instant Lockpick"
													}, {
														Type = "Information",
														Text = "Feature also gives you infinite lockpick tries, meaning you have infinite lockpicks."
												
													}

												})
													
											CharacterTab3:CreateObject(function(Type, Flag, Value, Selected)
												BlackoutSettings.AutoLoot = Value
													end, {
														{
														Type = "Toggle",
														Default = false,
														Flag = "Toggle"
													}, {
														Type = "Label",
														Text = "Auto Loot"
													}
								
								
												})





					
												local CharacterTab4 = MiscTab:Groupbox({
													Title = "Player List",
													Side = 1
												})

												local CharacterTab5 = MiscTab:Groupbox({
													Title = "Other Miscellaneous",
													Side = 2
												})

							

												local following = false

												CharacterTab4:CreateObject(function(Type, Flag, Value, Selected)
													if Type == "Dropdown" then
														selectedPlayer = Value -- Store the selected player name
													end
												end, {
													{
														Type = "Dropdown",
														Text = "Select Player:",
														Items = (function()
															local playerList = {}
															for _, player in ipairs(game.Players:GetPlayers()) do
																if player ~= game.Players.LocalPlayer then
																	table.insert(playerList, player.Name)
																end
															end
															return playerList
														end)(),
														Defaults = { [1] = true },
														Default = 1,
														SelectMultiple = false,
														CloseAfterSelection = true,
														NoStartCallback = true
													},
												})
												
												
												
							
												
															CharacterTab4:CreateObject(function(Type, Flag, Value, Selected)
																if Type == "Toggle" then
																	following = Value
																	local targetPlayer = game.Players:FindFirstChild(selectedPlayer)
															
																	if following then
																		if targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
																			workspace.CurrentCamera.CameraType = Enum.CameraType.Scriptable
															
																			-- Create a loop to keep updating the camera's position
																			while following do
																				wait(0.01) -- Adjust the wait time as needed
																				if targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
																					workspace.CurrentCamera.CFrame = CFrame.new(targetPlayer.Character.HumanoidRootPart.Position + Vector3.new(0, 5, 10), targetPlayer.Character.HumanoidRootPart.Position)
																				else
																					break -- Exit the loop if the target no longer exists
																				end
																			end
																		end
																	else
																		workspace.CurrentCamera.CameraType = Enum.CameraType.Custom -- Reset the camera
																	end
																end
															end, {
																{
																	Type = "Toggle",
																	Default = false,
																	Flag = "Toggle"
																}, {
																	Type = "Label",
																	Text = "View target"
																}
															})
					
															CharacterTab4:CreateObject(function(Type, Flag, Value, Selected)
												
															end, {
															{

															
																	Type = "Label",
																	Text = "Whitelisting"
																}
					
						
														})

																

-- Dropdown to select players for whitelist
CharacterTab4:CreateObject(function(Type, Flag, Value, Selected)
    if Type == "Dropdown" then
        -- Ensure the selected players are in a valid table
        if typeof(Value) == "string" then
            selectedPlayers = { Value }
        else
            selectedPlayers = Value or {}
        end
    end
end, {
    {
        Type = "Dropdown",
        Text = "Select Player(s):",
        Items = (function()
            local playerList = {}
            for _, player in ipairs(game.Players:GetPlayers()) do
                if player ~= game.Players.LocalPlayer then
                    table.insert(playerList, player.Name)
                end
            end
            return playerList
        end)(),
        Defaults = { [1] = true },
        Default = 1,
        SelectMultiple = true,
        CloseAfterSelection = true,
        NoStartCallback = true
    },
})


-- Toggle to add/remove selected players to/from the whitelist
CharacterTab4:CreateObject(function(Type, Flag, Value, Selected)
    if Type == "Toggle" then
        for _, playerName in ipairs(selectedPlayers) do
            if Value then
                -- Add to whitelist
                whitelistedPlayersAutoshoot[playerName] = true
            else
                -- Remove from whitelist
                whitelistedPlayersAutoshoot[playerName] = nil
            end
        end
    end
end, {
    {
        Type = "Toggle",
        Default = false,
        Flag = "Toggle"
    },
    {
        Type = "Label",
        Text = "Whitelist from Autoshoot"
    }
})




															CharacterTab5:CreateObject(function(Type, Flag, Value, Selected)
																local CoreGui = game:GetService("CoreGui")
																local ExperienceChat = CoreGui:FindFirstChild("ExperienceChat")
																
																if ExperienceChat then
																	local ChatInputBar = ExperienceChat.appLayout:FindFirstChild("chatInputBar")
																	local ChatWindow = ExperienceChat.appLayout:FindFirstChild("chatWindow")
																	
																	if ChatInputBar and ChatWindow then
																		-- Check the boolean value
																		if not Value then
																			-- Hide chat window and adjust input bar position
																			ChatWindow.Visible = false
																			ChatInputBar.Position = UDim2.new(0, 0, 0, 0) -- Adjust position as needed
																		else
																			-- Show chat window and adjust input bar position
																			ChatWindow.Visible = true
																			ChatInputBar.Position = UDim2.new(0, 0, 0, ChatWindow.Size.Y.Offset)
																		end
																	end
																end
																
																	end, {
																		{
																		Type = "Toggle",
																		Default = false,
																		Flag = "Toggle"
																	}, {
																		Type = "Label",
																		Text = "Show Chat"
																	}
												
												
																})



																CharacterTab5:CreateObject(function(Type, Flag, Value, Selected)
if Value == true then
	game.Players.LocalPlayer.CameraMaxZoomDistance = 55555
else
	game.Players.LocalPlayer.CameraMaxZoomDistance = 10
end
															end, {
																{
																Type = "Toggle",
																Default = false,
																Flag = "Toggle"
															}, {
																Type = "Label",
																Text = "Maximum Zoom Distance"
															}
										
										
														})


																local CharacterTab6 = MiscTab:Groupbox({
																	Title = "Camouflage Settings",
																	Side = 2
																})
																
																
																CharacterTab6:CreateObject(function(Type, Flag, Value, Selected)
																BlackoutSettings.HideLevel = Value
																end, {
																	{
																		Type = "Toggle",
																		Default = false,
																		Flag = "Toggle"
																	}, {
																		Type = "Label",
																		Text = "Mask Level"
																	}
																})

																CharacterTab6:CreateObject(function(Type, Flag, Value, Selected)

																BlackoutSettings.HidePartyMembers = Value
																
															end, {
																{
																	Type = "Toggle",
																	Default = false,
																	Flag = "Toggle"
																}, {
																	Type = "Label",
																	Text = "Mask Party Members"
																}
															})
																CharacterTab6:CreateObject(function(Type, Flag, Value, Selected)
																BlackoutSettings.HideLeaderBoard = Value
																end, {
																	{
																		Type = "Toggle",
																		Default = false,
																		Flag = "Toggle"
																	}, {
																		Type = "Label",
																		Text = "Hide Leaderboard"
																	}
																})
																
																local CharacterTab7 = MiscTab:Groupbox({
																	Title = "Staff Detection Settings",
																	Side = 1
																})

																CharacterTab7:CreateObject(function(Type, Flag, Value, Selected)
																	Settings.DetectionEnabled = Value
																	end, {
																		{
																			Type = "Toggle",
																			Default = true,
																			Flag = "Toggle"
																		}, {
																			Type = "Label",
																			Text = "Enable Detection"
																		}
																	})
				
															

																	CharacterTab7:CreateObject(function(Type, Flag, Value, Selected)
																		if Value == 'Notification' then
														Settings.NotifyOnDetection = true
														Settings.KickOnDetection = false
													
																		elseif Value == 'Kick' then
Settings.KickOnDetection = true
Settings.NotifyOnDetection = false
													 end
																	end, {
										 
														{
															 Type = "Label",
															 Text = "Method:"
														 }, {
															 Type = "Dropdown",
															 Text = "Notification",
															 Items = {
																 "Notification",
																 "Kick",
															 },
															 Defaults = {
																 [1] = true, -- "sure :3!!"
													
															 },
															 Default = 1,
															 SelectMultiple = false,
															 CloseAfterSelection = true,
															 NoStartCallback = true
														
													 
													 }
														 })
																-- Services
local TeleportService = game:GetService("TeleportService")
local Players = game:GetService("Players")

-- Rejoin function
local function rejoinGame()
    local player = Players.LocalPlayer
    local placeId = game.PlaceId
    local jobId = game.JobId

    -- Rejoin the same server
    TeleportService:TeleportToPlaceInstance(placeId, jobId, player)
end


				
CharacterTab5:CreateObject(function(Type, Flag, Value, Selected)
	rejoinGame()
end, {

{
	Type = "Button",
	Flag = "Nutonme"
}, {
	Type = "Label",
	Text = "Rejoin Server"
}

})


local text = Drawing.new("Text")
text.Text = "Kinetic Rage [Slotted User]"
text.Color = Color3.fromRGB(255, 255, 255)
text.Size = 15
text.Center = true
text.Outline = false
text.Font = Drawing.Fonts.UI

local screenSize = workspace.CurrentCamera.ViewportSize
text.Position = Vector2.new(screenSize.X / 2, 0) 
text.Visible = true


_G.testWarningText = text


game.StarterGui:SetCore("SendNotification", {
    Title = "Kinetic";
    Text = "Loaded, UI Keybind: LEFT ALT";
    Icon = "rbxassetid://88195615011513";
    Duration = 5; 
    })
